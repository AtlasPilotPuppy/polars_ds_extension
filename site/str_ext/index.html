
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../stats_ext/">
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.5.2">
    
    
      
        <title>String Extension - Polars-ds Docs</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.50c56a3b.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../assets/_mkdocstrings.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#extension-for-string-manipulation-and-metrics" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Polars-ds Docs" class="md-header__button md-logo" aria-label="Polars-ds Docs" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Polars-ds Docs
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              String Extension
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Polars-ds Docs" class="md-nav__button md-logo" aria-label="Polars-ds Docs" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Polars-ds Docs
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../complex_ext/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Complex Extension
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../num_ext/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Numerical Extension
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../stats_ext/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Stats Extension
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    String Extension
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    String Extension
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#extension-for-string-manipulation-and-metrics" class="md-nav__link">
    <span class="md-ellipsis">
      Extension for String Manipulation and Metrics
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#polars_ds.str_ext" class="md-nav__link">
    <span class="md-ellipsis">
      str_ext
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt" class="md-nav__link">
    <span class="md-ellipsis">
      StrExt
    </span>
  </a>
  
    <nav class="md-nav" aria-label="StrExt">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.ac_match" class="md-nav__link">
    <span class="md-ellipsis">
      ac_match()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ac_match()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.ac_match--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.ac_replace" class="md-nav__link">
    <span class="md-ellipsis">
      ac_replace()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ac_replace()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.ac_replace--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.d_levenshtein" class="md-nav__link">
    <span class="md-ellipsis">
      d_levenshtein()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="d_levenshtein()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.d_levenshtein--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.extract_numbers" class="md-nav__link">
    <span class="md-ellipsis">
      extract_numbers()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="extract_numbers()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.extract_numbers--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.extract_numbers--examples" class="md-nav__link">
    <span class="md-ellipsis">
      Examples
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.freq_removal" class="md-nav__link">
    <span class="md-ellipsis">
      freq_removal()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="freq_removal()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.freq_removal--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.hamming" class="md-nav__link">
    <span class="md-ellipsis">
      hamming()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="hamming()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.hamming--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.infer_infreq" class="md-nav__link">
    <span class="md-ellipsis">
      infer_infreq()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="infer_infreq()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.infer_infreq--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.is_stopword" class="md-nav__link">
    <span class="md-ellipsis">
      is_stopword()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.jaro" class="md-nav__link">
    <span class="md-ellipsis">
      jaro()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="jaro()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.jaro--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.jw" class="md-nav__link">
    <span class="md-ellipsis">
      jw()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="jw()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.jw--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.levenshtein" class="md-nav__link">
    <span class="md-ellipsis">
      levenshtein()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="levenshtein()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.levenshtein--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.levenshtein_within" class="md-nav__link">
    <span class="md-ellipsis">
      levenshtein_within()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="levenshtein_within()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.levenshtein_within--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.line_count" class="md-nav__link">
    <span class="md-ellipsis">
      line_count()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.merge_infreq" class="md-nav__link">
    <span class="md-ellipsis">
      merge_infreq()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="merge_infreq()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.merge_infreq--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.osa" class="md-nav__link">
    <span class="md-ellipsis">
      osa()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="osa()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.osa--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.overlap_coeff" class="md-nav__link">
    <span class="md-ellipsis">
      overlap_coeff()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="overlap_coeff()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.overlap_coeff--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.snowball" class="md-nav__link">
    <span class="md-ellipsis">
      snowball()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="snowball()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.snowball--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.sorensen_dice" class="md-nav__link">
    <span class="md-ellipsis">
      sorensen_dice()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="sorensen_dice()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.sorensen_dice--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.str_jaccard" class="md-nav__link">
    <span class="md-ellipsis">
      str_jaccard()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="str_jaccard()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.str_jaccard--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.tokenize" class="md-nav__link">
    <span class="md-ellipsis">
      tokenize()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="tokenize()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.tokenize--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#extension-for-string-manipulation-and-metrics" class="md-nav__link">
    <span class="md-ellipsis">
      Extension for String Manipulation and Metrics
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#polars_ds.str_ext" class="md-nav__link">
    <span class="md-ellipsis">
      str_ext
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt" class="md-nav__link">
    <span class="md-ellipsis">
      StrExt
    </span>
  </a>
  
    <nav class="md-nav" aria-label="StrExt">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.ac_match" class="md-nav__link">
    <span class="md-ellipsis">
      ac_match()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ac_match()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.ac_match--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.ac_replace" class="md-nav__link">
    <span class="md-ellipsis">
      ac_replace()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ac_replace()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.ac_replace--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.d_levenshtein" class="md-nav__link">
    <span class="md-ellipsis">
      d_levenshtein()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="d_levenshtein()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.d_levenshtein--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.extract_numbers" class="md-nav__link">
    <span class="md-ellipsis">
      extract_numbers()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="extract_numbers()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.extract_numbers--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.extract_numbers--examples" class="md-nav__link">
    <span class="md-ellipsis">
      Examples
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.freq_removal" class="md-nav__link">
    <span class="md-ellipsis">
      freq_removal()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="freq_removal()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.freq_removal--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.hamming" class="md-nav__link">
    <span class="md-ellipsis">
      hamming()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="hamming()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.hamming--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.infer_infreq" class="md-nav__link">
    <span class="md-ellipsis">
      infer_infreq()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="infer_infreq()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.infer_infreq--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.is_stopword" class="md-nav__link">
    <span class="md-ellipsis">
      is_stopword()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.jaro" class="md-nav__link">
    <span class="md-ellipsis">
      jaro()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="jaro()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.jaro--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.jw" class="md-nav__link">
    <span class="md-ellipsis">
      jw()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="jw()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.jw--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.levenshtein" class="md-nav__link">
    <span class="md-ellipsis">
      levenshtein()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="levenshtein()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.levenshtein--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.levenshtein_within" class="md-nav__link">
    <span class="md-ellipsis">
      levenshtein_within()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="levenshtein_within()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.levenshtein_within--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.line_count" class="md-nav__link">
    <span class="md-ellipsis">
      line_count()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.merge_infreq" class="md-nav__link">
    <span class="md-ellipsis">
      merge_infreq()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="merge_infreq()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.merge_infreq--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.osa" class="md-nav__link">
    <span class="md-ellipsis">
      osa()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="osa()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.osa--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.overlap_coeff" class="md-nav__link">
    <span class="md-ellipsis">
      overlap_coeff()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="overlap_coeff()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.overlap_coeff--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.snowball" class="md-nav__link">
    <span class="md-ellipsis">
      snowball()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="snowball()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.snowball--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.sorensen_dice" class="md-nav__link">
    <span class="md-ellipsis">
      sorensen_dice()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="sorensen_dice()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.sorensen_dice--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.str_jaccard" class="md-nav__link">
    <span class="md-ellipsis">
      str_jaccard()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="str_jaccard()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.str_jaccard--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.tokenize" class="md-nav__link">
    <span class="md-ellipsis">
      tokenize()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="tokenize()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polars_ds.str_ext.StrExt.tokenize--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  <h1>String Extension</h1>

<h2 id="extension-for-string-manipulation-and-metrics">Extension for String Manipulation and Metrics</h2>


<div class="doc doc-object doc-module">



<a id="polars_ds.str_ext"></a>
  <div class="doc doc-contents first">

  

  <div class="doc doc-children">








<div class="doc doc-object doc-class">




<h2 id="polars_ds.str_ext.StrExt" class="doc doc-heading">
          <code>StrExt</code>


</h2>


  <div class="doc doc-contents ">

  
      <p>This class contains tools for dealing with string similarity, common string operations like tokenize,
extract numbers, etc., inside Polars DataFrame.</p>
<p>Polars Namespace: str_ext</p>
<p>Example: pl.col("a").str_ext.levenshtein(pl.col("b"), return_sim=True)</p>

            <details class="quote">
              <summary>Source code in <code>python/polars_ds/str_ext.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 10</span>
<span class="normal"> 11</span>
<span class="normal"> 12</span>
<span class="normal"> 13</span>
<span class="normal"> 14</span>
<span class="normal"> 15</span>
<span class="normal"> 16</span>
<span class="normal"> 17</span>
<span class="normal"> 18</span>
<span class="normal"> 19</span>
<span class="normal"> 20</span>
<span class="normal"> 21</span>
<span class="normal"> 22</span>
<span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span>
<span class="normal">651</span>
<span class="normal">652</span>
<span class="normal">653</span>
<span class="normal">654</span>
<span class="normal">655</span>
<span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span>
<span class="normal">663</span>
<span class="normal">664</span>
<span class="normal">665</span>
<span class="normal">666</span>
<span class="normal">667</span>
<span class="normal">668</span>
<span class="normal">669</span>
<span class="normal">670</span>
<span class="normal">671</span>
<span class="normal">672</span>
<span class="normal">673</span>
<span class="normal">674</span>
<span class="normal">675</span>
<span class="normal">676</span>
<span class="normal">677</span>
<span class="normal">678</span>
<span class="normal">679</span>
<span class="normal">680</span>
<span class="normal">681</span>
<span class="normal">682</span>
<span class="normal">683</span>
<span class="normal">684</span>
<span class="normal">685</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@pl</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">register_expr_namespace</span><span class="p">(</span><span class="s2">&quot;str_ext&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">StrExt</span><span class="p">:</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class contains tools for dealing with string similarity, common string operations like tokenize,</span>
<span class="sd">    extract numbers, etc., inside Polars DataFrame.</span>

<span class="sd">    Polars Namespace: str_ext</span>

<span class="sd">    Example: pl.col(&quot;a&quot;).str_ext.levenshtein(pl.col(&quot;b&quot;), return_sim=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="p">:</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span> <span class="o">=</span> <span class="n">expr</span>

    <span class="k">def</span> <span class="nf">is_stopword</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether the string is a stopword or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
            <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
            <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_is_stopword&quot;</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="p">[],</span>
            <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">extract_numbers</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">ignore_comma</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">join_by</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">pl</span><span class="o">.</span><span class="n">DataType</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">Utf8</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts numbers from the string column, and stores them in a list.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ignore_comma</span>
<span class="sd">            Whether to remove all comma before matching for numbers</span>
<span class="sd">        join_by</span>
<span class="sd">            If dtype is pl.Utf8, join the list of strings using the value given here</span>
<span class="sd">        dtype</span>
<span class="sd">            The desired inner dtype for the extracted data. Should either be one of</span>
<span class="sd">            pl.NUMERIC_DTYPES or pl.Utf8</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pl.DataFrame({</span>
<span class="sd">        ...     &quot;survey&quot;:[&quot;0% of my time&quot;, &quot;1% to 25% of my time&quot;, &quot;75% to 99% of my time&quot;,</span>
<span class="sd">        ...            &quot;50% to 74% of my time&quot;, &quot;75% to 99% of my time&quot;,</span>
<span class="sd">        ...            &quot;50% to 74% of my time&quot;]</span>
<span class="sd">        ... })</span>
<span class="sd">        &gt;&gt;&gt; df.select(pl.col(&quot;survey&quot;).str_ext.extract_numbers(dtype=pl.UInt32))</span>
<span class="sd">        shape: (6, 1)</span>
<span class="sd">        ┌───────────┐</span>
<span class="sd">        │ survey    │</span>
<span class="sd">        │ ---       │</span>
<span class="sd">        │ list[u32] │</span>
<span class="sd">        ╞═══════════╡</span>
<span class="sd">        │ [0]       │</span>
<span class="sd">        │ [1, 25]   │</span>
<span class="sd">        │ [75, 99]  │</span>
<span class="sd">        │ [50, 74]  │</span>
<span class="sd">        │ [75, 99]  │</span>
<span class="sd">        │ [50, 74]  │</span>
<span class="sd">        └───────────┘</span>
<span class="sd">        &gt;&gt;&gt; df.select(pl.col(&quot;survey&quot;).str_ext.extract_numbers(join_by=&quot;-&quot;, dtype=pl.Utf8))</span>
<span class="sd">        shape: (6, 1)</span>
<span class="sd">        ┌────────┐</span>
<span class="sd">        │ survey │</span>
<span class="sd">        │ ---    │</span>
<span class="sd">        │ str    │</span>
<span class="sd">        ╞════════╡</span>
<span class="sd">        │ 0      │</span>
<span class="sd">        │ 1-25   │</span>
<span class="sd">        │ 75-99  │</span>
<span class="sd">        │ 50-74  │</span>
<span class="sd">        │ 75-99  │</span>
<span class="sd">        │ 50-74  │</span>
<span class="sd">        └────────┘</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span>
        <span class="k">if</span> <span class="n">ignore_comma</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">replace_all</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="c1"># Find all numbers</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">extract_all</span><span class="p">(</span><span class="s2">&quot;(\d*\.?\d+)&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="n">pl</span><span class="o">.</span><span class="n">NUMERIC_DTYPES</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">list</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">pl</span><span class="o">.</span><span class="n">element</span><span class="p">()</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">pl</span><span class="o">.</span><span class="n">Utf8</span><span class="p">:</span>  <span class="c1"># As a list of strings</span>
            <span class="k">if</span> <span class="n">join_by</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">list</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">join_by</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">expr</span>

    <span class="k">def</span> <span class="nf">line_count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the line count of the string column.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">count_matches</span><span class="p">(</span><span class="n">pattern</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">infer_infreq</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">min_count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">min_frac</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Infers infrequent categories (strings) by min_count or min_frac and return a list as output.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        min_count</span>
<span class="sd">            If set, an infrequency category will be defined as a category with count &lt; this.</span>
<span class="sd">        min_frac</span>
<span class="sd">            If set, an infrequency category will be defined as a category with pct &lt; this. min_count</span>
<span class="sd">            takes priority over this.</span>
<span class="sd">        parallel</span>
<span class="sd">            Whether to run value_counts in parallel. This may not provide much speed up and is not</span>
<span class="sd">            recommended in a group_by context.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">root_names</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">vc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">value_counts</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">min_count</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">min_frac</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Either min_count or min_frac must be provided.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">min_count</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">infreq</span><span class="p">:</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span> <span class="o">=</span> <span class="n">vc</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">vc</span><span class="o">.</span><span class="n">struct</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_count</span><span class="p">)</span><span class="o">.</span><span class="n">struct</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">min_frac</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">infreq</span><span class="p">:</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span> <span class="o">=</span> <span class="n">vc</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                <span class="n">vc</span><span class="o">.</span><span class="n">struct</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">)</span> <span class="o">/</span> <span class="n">vc</span><span class="o">.</span><span class="n">struct</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">min_frac</span>
            <span class="p">)</span><span class="o">.</span><span class="n">struct</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">infreq</span><span class="o">.</span><span class="n">implode</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">merge_infreq</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">min_count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">min_frac</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">separator</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;|&quot;</span><span class="p">,</span>
        <span class="n">parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge infrequent categories (strings) in the column into one category (string) separated by a</span>
<span class="sd">        separator. This is useful when you want to do one-hot-encoding but do not want too many distinct</span>
<span class="sd">        values because of low count values. However, this does not mean that the categories are similar</span>
<span class="sd">        with respect to the your modelling problem.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        min_count</span>
<span class="sd">            If set, an infrequency category will be defined as a category with count &lt; this.</span>
<span class="sd">        min_frac</span>
<span class="sd">            If set, an infrequency category will be defined as a category with pct &lt; this. min_count</span>
<span class="sd">            takes priority over this.</span>
<span class="sd">        separator</span>
<span class="sd">            What separator to use when joining the categories. E.g if &quot;a&quot; and &quot;b&quot; are rare categories,</span>
<span class="sd">            and separator = &quot;|&quot;, they will be mapped to &quot;a|b&quot;</span>
<span class="sd">        parallel</span>
<span class="sd">            Whether to run value_counts in parallel. This may not provide much speed up and is not</span>
<span class="sd">            recommended in a group_by context.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Will be fixed soon and sort will not be needed</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">root_names</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">vc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">value_counts</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">min_count</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">min_frac</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Either min_count or min_frac must be provided.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">min_count</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">to_merge</span><span class="p">:</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span> <span class="o">=</span> <span class="n">vc</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">vc</span><span class="o">.</span><span class="n">struct</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_count</span><span class="p">)</span><span class="o">.</span><span class="n">struct</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">min_frac</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">to_merge</span><span class="p">:</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span> <span class="o">=</span> <span class="n">vc</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                <span class="n">vc</span><span class="o">.</span><span class="n">struct</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">)</span> <span class="o">/</span> <span class="n">vc</span><span class="o">.</span><span class="n">struct</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">min_frac</span>
            <span class="p">)</span><span class="o">.</span><span class="n">struct</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">pl</span><span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">is_in</span><span class="p">(</span><span class="n">to_merge</span><span class="p">))</span>
            <span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">to_merge</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">pl</span><span class="o">.</span><span class="n">Utf8</span><span class="p">)</span><span class="o">.</span><span class="n">fill_null</span><span class="p">(</span><span class="s2">&quot;null&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">implode</span><span class="p">()</span><span class="o">.</span><span class="n">first</span><span class="p">()</span><span class="o">.</span><span class="n">list</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">separator</span><span class="p">))</span>
            <span class="o">.</span><span class="n">otherwise</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">str_jaccard</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">],</span> <span class="n">substr_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Treats substrings of size `substr_size` as a set. And computes the jaccard similarity between</span>
<span class="sd">        this word and the other. This is not the same as comparing bigrams.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other</span>
<span class="sd">            If this is a string, then the entire column will be compared with this string. If this</span>
<span class="sd">            is an expression, then perform element-wise jaccard similarity computation between this column</span>
<span class="sd">            and the other (given by the expression).</span>
<span class="sd">        substr_size</span>
<span class="sd">            The substring size for Jaccard similarity. E.g. if substr_size = 2, &quot;apple&quot; will be decomposed into</span>
<span class="sd">            the set (&#39;ap&#39;, &#39;pp&#39;, &#39;pl&#39;, &#39;le&#39;) before being compared.</span>
<span class="sd">        parallel</span>
<span class="sd">            Whether to run the comparisons in parallel. Note that this is not always faster, especially</span>
<span class="sd">            when used with other expressions or in group_by/over context.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">other_</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pl</span><span class="o">.</span><span class="n">Utf8</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">other_</span> <span class="o">=</span> <span class="n">other</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
            <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
            <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_str_jaccard&quot;</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">other_</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">substr_size</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">UInt32</span><span class="p">),</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">parallel</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)],</span>
            <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">sorensen_dice</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">],</span> <span class="n">substr_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Treats substrings of size `substr_size` as a set. And computes the Sorensen-Dice similarity between</span>
<span class="sd">        this word and the other. This is not the same as comparing bigrams.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other</span>
<span class="sd">            If this is a string, then the entire column will be compared with this string. If this</span>
<span class="sd">            is an expression, then perform element-wise jaccard similarity computation between this column</span>
<span class="sd">            and the other (given by the expression).</span>
<span class="sd">        substr_size</span>
<span class="sd">            The substring size for Jaccard similarity. E.g. if substr_size = 2, &quot;apple&quot; will be decomposed into</span>
<span class="sd">            the set (&#39;ap&#39;, &#39;pp&#39;, &#39;pl&#39;, &#39;le&#39;) before being compared.</span>
<span class="sd">        parallel</span>
<span class="sd">            Whether to run the comparisons in parallel. Note that this is not always faster, especially</span>
<span class="sd">            when used with other expressions or in group_by/over context.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">other_</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pl</span><span class="o">.</span><span class="n">Utf8</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">other_</span> <span class="o">=</span> <span class="n">other</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
            <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
            <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_sorensen_dice&quot;</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">other_</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">substr_size</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">UInt32</span><span class="p">),</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">parallel</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)],</span>
            <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">overlap_coeff</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">],</span> <span class="n">substr_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Treats substrings of size `substr_size` as a set. And computes the overlap coefficient as</span>
<span class="sd">        similarity between this word and the other. This is not the same as comparing bigrams.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other</span>
<span class="sd">            If this is a string, then the entire column will be compared with this string. If this</span>
<span class="sd">            is an expression, then perform element-wise jaccard similarity computation between this column</span>
<span class="sd">            and the other (given by the expression).</span>
<span class="sd">        substr_size</span>
<span class="sd">            The substring size for Jaccard similarity. E.g. if substr_size = 2, &quot;apple&quot; will be decomposed into</span>
<span class="sd">            the set (&#39;ap&#39;, &#39;pp&#39;, &#39;pl&#39;, &#39;le&#39;) before being compared.</span>
<span class="sd">        parallel</span>
<span class="sd">            Whether to run the comparisons in parallel. Note that this is not always faster, especially</span>
<span class="sd">            when used with other expressions or in group_by/over context.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">other_</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Utf8</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">other_</span> <span class="o">=</span> <span class="n">other</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
            <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
            <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_overlap_coeff&quot;</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">other_</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">substr_size</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">UInt32</span><span class="p">),</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">parallel</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)],</span>
            <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">levenshtein</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">],</span> <span class="n">parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">return_sim</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the Levenshtein distance between this and the other str.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other</span>
<span class="sd">            If this is a string, then the entire column will be compared with this string. If this</span>
<span class="sd">            is an expression, then an element-wise Levenshtein distance computation between this column</span>
<span class="sd">            and the other (given by the expression) will be performed.</span>
<span class="sd">        parallel</span>
<span class="sd">            Whether to run the comparisons in parallel. Note that this is not always faster, especially</span>
<span class="sd">            when used with other expressions or in group_by/over context.</span>
<span class="sd">        return_sim</span>
<span class="sd">            If true, return normalized Levenshtein.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">other_</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pl</span><span class="o">.</span><span class="n">Utf8</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">other_</span> <span class="o">=</span> <span class="n">other</span>

        <span class="k">if</span> <span class="n">return_sim</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
                <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
                <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_levenshtein_sim&quot;</span><span class="p">,</span>
                <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">other_</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">parallel</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)],</span>
                <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
                <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
                <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_levenshtein&quot;</span><span class="p">,</span>
                <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">other_</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">parallel</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)],</span>
                <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">levenshtein_within</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">],</span>
        <span class="n">bound</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns whether the Levenshtein distance between self and other is &lt;= bound. This is much</span>
<span class="sd">        faster than computing levenshtein distance and then doing &lt;= bound.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other</span>
<span class="sd">            If this is a string, then the entire column will be compared with this string. If this</span>
<span class="sd">            is an expression, then an element-wise Levenshtein distance computation between this column</span>
<span class="sd">            and the other (given by the expression) will be performed.</span>
<span class="sd">        bound</span>
<span class="sd">            Closed upper bound. If levenshtein distance &lt;= bound, return true and false otherwise.</span>
<span class="sd">        parallel</span>
<span class="sd">            Whether to run the comparisons in parallel. Note that this is not always faster, especially</span>
<span class="sd">            when used with other expressions or in group_by/over context.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">other_</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Utf8</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">other_</span> <span class="o">=</span> <span class="n">other</span>

        <span class="n">bound</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">bound</span><span class="p">),</span> <span class="n">pl</span><span class="o">.</span><span class="n">UInt32</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
            <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
            <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_levenshtein_within&quot;</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">other_</span><span class="p">,</span> <span class="n">bound</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">parallel</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)],</span>
            <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">d_levenshtein</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">],</span> <span class="n">parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">return_sim</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the Damerau-Levenshtein distance between this and the other str.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other</span>
<span class="sd">            If this is a string, then the entire column will be compared with this string. If this</span>
<span class="sd">            is an expression, then an element-wise Levenshtein distance computation between this column</span>
<span class="sd">            and the other (given by the expression) will be performed.</span>
<span class="sd">        parallel</span>
<span class="sd">            Whether to run the comparisons in parallel. Note that this is not always faster, especially</span>
<span class="sd">            when used with other expressions or in group_by/over context.</span>
<span class="sd">        return_sim</span>
<span class="sd">            If true, return normalized Damerau-Levenshtein.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">other_</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pl</span><span class="o">.</span><span class="n">Utf8</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">other_</span> <span class="o">=</span> <span class="n">other</span>

        <span class="k">if</span> <span class="n">return_sim</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
                <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
                <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_d_levenshtein_sim&quot;</span><span class="p">,</span>
                <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">other_</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">parallel</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)],</span>
                <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
                <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
                <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_d_levenshtein&quot;</span><span class="p">,</span>
                <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">other_</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">parallel</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)],</span>
                <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">osa</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">],</span> <span class="n">parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">return_sim</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the Optimal String Alignment distance between this and the other str.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other</span>
<span class="sd">            If this is a string, then the entire column will be compared with this string. If this</span>
<span class="sd">            is an expression, then an element-wise OSA distance computation between this column</span>
<span class="sd">            and the other (given by the expression) will be performed.</span>
<span class="sd">        parallel</span>
<span class="sd">            Whether to run the comparisons in parallel. Note that this is not always faster, especially</span>
<span class="sd">            when used with other expressions or in group_by/over context.</span>
<span class="sd">        return_sim</span>
<span class="sd">            If true, return normalized OSA similarity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">other_</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pl</span><span class="o">.</span><span class="n">Utf8</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">other_</span> <span class="o">=</span> <span class="n">other</span>

        <span class="k">if</span> <span class="n">return_sim</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
                <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
                <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_osa_sim&quot;</span><span class="p">,</span>
                <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">other_</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">parallel</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)],</span>
                <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
                <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
                <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_osa&quot;</span><span class="p">,</span>
                <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">other_</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">parallel</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)],</span>
                <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">jaro</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">],</span> <span class="n">parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the Jaro similarity between this and the other str. Jaro distance = 1 - Jaro sim.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other</span>
<span class="sd">            If this is a string, then the entire column will be compared with this string. If this</span>
<span class="sd">            is an expression, then an element-wise Levenshtein distance computation between this column</span>
<span class="sd">            and the other (given by the expression) will be performed.</span>
<span class="sd">        parallel</span>
<span class="sd">            Whether to run the comparisons in parallel. Note that this is not always faster, especially</span>
<span class="sd">            when used with other expressions or in group_by/over context.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">other_</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pl</span><span class="o">.</span><span class="n">Utf8</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">other_</span> <span class="o">=</span> <span class="n">other</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
            <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
            <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_jaro&quot;</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">other_</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">parallel</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)],</span>
            <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">jw</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">],</span> <span class="n">weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the Jaro-Winker similarity between this and the other str.</span>
<span class="sd">        Jaro-Winkler distance = 1 - Jaro-Winkler sim.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other</span>
<span class="sd">            If this is a string, then the entire column will be compared with this string. If this</span>
<span class="sd">            is an expression, then an element-wise Levenshtein distance computation between this column</span>
<span class="sd">            and the other (given by the expression) will be performed.</span>
<span class="sd">        weight</span>
<span class="sd">            Weight for prefix. A typical value is 0.1.</span>
<span class="sd">        parallel</span>
<span class="sd">            Whether to run the comparisons in parallel. Note that this is not always faster, especially</span>
<span class="sd">            when used with other expressions or in group_by/over context.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">other_</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Utf8</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">other_</span> <span class="o">=</span> <span class="n">other</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
            <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
            <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_jw&quot;</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">other_</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Float64</span><span class="p">),</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">parallel</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)],</span>
            <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">hamming</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">],</span> <span class="n">pad</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the hamming distance between two strings. If they do not have the same length, null will</span>
<span class="sd">        be returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other</span>
<span class="sd">            If this is a string, then the entire column will be compared with this string. If this</span>
<span class="sd">            is an expression, then an element-wise hamming distance computation between this column</span>
<span class="sd">            and the other (given by the expression) will be performed.</span>
<span class="sd">        pad</span>
<span class="sd">            Whether to pad the string when lengths are not equal.</span>
<span class="sd">        parallel</span>
<span class="sd">            Whether to run the comparisons in parallel. Note that this is not always faster, especially</span>
<span class="sd">            when used with other expressions or in group_by/over context.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">other_</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">other_</span> <span class="o">=</span> <span class="n">other</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
            <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
            <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_hamming&quot;</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">other_</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">pad</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">),</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">parallel</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)],</span>
            <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">tokenize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;(?u)\b\w\w+\b&quot;</span><span class="p">,</span> <span class="n">stem</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tokenize the string according to the pattern. This will only extract the words</span>
<span class="sd">        satisfying the pattern.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pattern</span>
<span class="sd">            The word pattern to extract</span>
<span class="sd">        stem</span>
<span class="sd">            If true, then this will stem the words and keep only the unique ones. Stop words</span>
<span class="sd">            will be removed. (Common words like `he`, `she`, etc., will be removed.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">extract_all</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stem</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">list</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span>
                <span class="n">pl</span><span class="o">.</span><span class="n">element</span><span class="p">()</span>
                <span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
                    <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
                    <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_snowball_stem&quot;</span><span class="p">,</span>
                    <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">),</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)],</span>
                    <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>  <span class="c1"># True to no stop word, False to Parallel</span>
                <span class="o">.</span><span class="n">drop_nulls</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">freq_removal</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">lower</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span> <span class="n">upper</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.95</span><span class="p">,</span> <span class="n">parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes from each documents words that are too frequent (in the entire dataset). This assumes</span>
<span class="sd">        that the input expression represents lists of strings. E.g. output of tokenize.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lower</span>
<span class="sd">            Lower percentile. If a word&#39;s frequency is &lt; than this, it will be removed.</span>
<span class="sd">        upper</span>
<span class="sd">            Upper percentile. If a word&#39;s frequency is &gt; than this, it will be removed.</span>
<span class="sd">        parallel</span>
<span class="sd">            Whether to run word count in parallel. It is not recommended when you are in a group_by</span>
<span class="sd">            context.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">root_names</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">vc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">list</span><span class="o">.</span><span class="n">explode</span><span class="p">()</span><span class="o">.</span><span class="n">value_counts</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">)</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">lo</span> <span class="o">=</span> <span class="n">vc</span><span class="o">.</span><span class="n">struct</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">vc</span><span class="o">.</span><span class="n">struct</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span>
        <span class="n">remove</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">vc</span><span class="o">.</span><span class="n">filter</span><span class="p">((</span><span class="n">vc</span><span class="o">.</span><span class="n">struct</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">lo</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">vc</span><span class="o">.</span><span class="n">struct</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">u</span><span class="p">))</span>
            <span class="o">.</span><span class="n">struct</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="o">.</span><span class="n">implode</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">list</span><span class="o">.</span><span class="n">set_difference</span><span class="p">(</span><span class="n">remove</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">snowball</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">no_stopwords</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies the snowball stemmer for the column. The column is supposed to be a column of single words.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        no_stopwords</span>
<span class="sd">            If true, stopwords will be mapped to None. If false, stopwords will be stemmed.</span>
<span class="sd">        parallel</span>
<span class="sd">            Whether to run the comparisons in parallel. Note that this is not always faster, especially</span>
<span class="sd">            when used with other expressions or in group_by/over context.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
            <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
            <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_snowball_stem&quot;</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">no_stopwords</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">),</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">parallel</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)],</span>
            <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">ac_match</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">patterns</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">case_sensitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">match_kind</span><span class="p">:</span> <span class="n">AhoCorasickMatchKind</span> <span class="o">=</span> <span class="s2">&quot;standard&quot;</span><span class="p">,</span>
        <span class="n">return_str</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Try to match the patterns using the Aho-Corasick algorithm. The matched pattern&#39;s indices will be</span>
<span class="sd">        returned. E.g. If for string1, pattern 2, 1, 3 are matched in this order, then [1, 0, 2] are</span>
<span class="sd">        returned. (Indices in pattern list)</span>

<span class="sd">        Polars &gt;= 0.20 now has native aho-corasick support. The backend package is the same, though the function</span>
<span class="sd">        api is different. See polars&#39;s str.contains_any and str.replace_many.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        patterns</span>
<span class="sd">            A list of strs, which are patterns to be matched</span>
<span class="sd">        case_sensitive</span>
<span class="sd">            Should this match be case sensitive? Default is false. Not working now.</span>
<span class="sd">        match_kind</span>
<span class="sd">            One of `standard`, `left_most_first`, or `left_most_longest`. For more information, see</span>
<span class="sd">            https://docs.rs/aho-corasick/latest/aho_corasick/enum.MatchKind.html. Any other input will</span>
<span class="sd">            be treated as standard.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Currently value_capacity for each list is hard-coded to 20. If there are more than 20 matches,</span>
        <span class="c1"># then this will be slow (doubling vec capacity)</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Argument `case_sensitive` does not seem to work right now.&quot;</span><span class="p">)</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;This function is unstable and is subject to change and may not perform well if there are more than &quot;</span>
            <span class="s2">&quot;20 matches. Read the source code or contact the author for more information. The most difficulty part &quot;</span>
            <span class="s2">&quot;is to design an output API that works well with Polars, which is harder than one might think.&quot;</span>
        <span class="p">)</span>

        <span class="n">pat</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">patterns</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pl</span><span class="o">.</span><span class="n">Utf8</span><span class="p">)</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">case_sensitive</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)</span>
        <span class="n">mk</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">match_kind</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Utf8</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_str</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
                <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
                <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_ac_match_str&quot;</span><span class="p">,</span>
                <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">pat</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">mk</span><span class="p">],</span>
                <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
                <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
                <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_ac_match&quot;</span><span class="p">,</span>
                <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">pat</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">mk</span><span class="p">],</span>
                <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">ac_replace</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">patterns</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">replacements</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Try to replace the patterns using the Aho-Corasick algorithm. The length of patterns should match</span>
<span class="sd">        the length of replacements. If not, both sequences will be capped at the shorter length. If an error</span>
<span class="sd">        happens during replacement, None will be returned.</span>

<span class="sd">        Polars &gt;= 0.20 now has native aho-corasick support. The backend package is the same, though the function</span>
<span class="sd">        api is different. See polars&#39;s str.contains_any and str.replace_many.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        patterns</span>
<span class="sd">            A list of strs, which are patterns to be matched</span>
<span class="sd">        replacements</span>
<span class="sd">            A list of strs to replace the patterns with</span>
<span class="sd">        parallel</span>
<span class="sd">            Whether to run the comparisons in parallel. Note that this is not always faster, especially</span>
<span class="sd">            when used with other expressions or in group_by/over context.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">replacements</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">patterns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span>

        <span class="n">mlen</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">patterns</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">replacements</span><span class="p">))</span>
        <span class="n">pat</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">patterns</span><span class="p">[:</span><span class="n">mlen</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pl</span><span class="o">.</span><span class="n">Utf8</span><span class="p">)</span>
        <span class="n">rpl</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">replacements</span><span class="p">[:</span><span class="n">mlen</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pl</span><span class="o">.</span><span class="n">Utf8</span><span class="p">)</span>
        <span class="n">par</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">parallel</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
            <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
            <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_ac_replace&quot;</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">pat</span><span class="p">,</span> <span class="n">rpl</span><span class="p">,</span> <span class="n">par</span><span class="p">],</span>
            <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>

  

  <div class="doc doc-children">










<div class="doc doc-object doc-function">




<h3 id="polars_ds.str_ext.StrExt.ac_match" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">ac_match</span><span class="p">(</span><span class="n">patterns</span><span class="p">,</span> <span class="n">case_sensitive</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">match_kind</span><span class="o">=</span><span class="s1">&#39;standard&#39;</span><span class="p">,</span> <span class="n">return_str</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Try to match the patterns using the Aho-Corasick algorithm. The matched pattern's indices will be
returned. E.g. If for string1, pattern 2, 1, 3 are matched in this order, then [1, 0, 2] are
returned. (Indices in pattern list)</p>
<p>Polars &gt;= 0.20 now has native aho-corasick support. The backend package is the same, though the function
api is different. See polars's str.contains_any and str.replace_many.</p>
<h5 id="polars_ds.str_ext.StrExt.ac_match--parameters">Parameters</h5>
<p>patterns
    A list of strs, which are patterns to be matched
case_sensitive
    Should this match be case sensitive? Default is false. Not working now.
match_kind
    One of <code>standard</code>, <code>left_most_first</code>, or <code>left_most_longest</code>. For more information, see
    https://docs.rs/aho-corasick/latest/aho_corasick/enum.MatchKind.html. Any other input will
    be treated as standard.</p>

          <details class="quote">
            <summary>Source code in <code>python/polars_ds/str_ext.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">ac_match</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">patterns</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">case_sensitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">match_kind</span><span class="p">:</span> <span class="n">AhoCorasickMatchKind</span> <span class="o">=</span> <span class="s2">&quot;standard&quot;</span><span class="p">,</span>
    <span class="n">return_str</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Try to match the patterns using the Aho-Corasick algorithm. The matched pattern&#39;s indices will be</span>
<span class="sd">    returned. E.g. If for string1, pattern 2, 1, 3 are matched in this order, then [1, 0, 2] are</span>
<span class="sd">    returned. (Indices in pattern list)</span>

<span class="sd">    Polars &gt;= 0.20 now has native aho-corasick support. The backend package is the same, though the function</span>
<span class="sd">    api is different. See polars&#39;s str.contains_any and str.replace_many.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    patterns</span>
<span class="sd">        A list of strs, which are patterns to be matched</span>
<span class="sd">    case_sensitive</span>
<span class="sd">        Should this match be case sensitive? Default is false. Not working now.</span>
<span class="sd">    match_kind</span>
<span class="sd">        One of `standard`, `left_most_first`, or `left_most_longest`. For more information, see</span>
<span class="sd">        https://docs.rs/aho-corasick/latest/aho_corasick/enum.MatchKind.html. Any other input will</span>
<span class="sd">        be treated as standard.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Currently value_capacity for each list is hard-coded to 20. If there are more than 20 matches,</span>
    <span class="c1"># then this will be slow (doubling vec capacity)</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Argument `case_sensitive` does not seem to work right now.&quot;</span><span class="p">)</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s2">&quot;This function is unstable and is subject to change and may not perform well if there are more than &quot;</span>
        <span class="s2">&quot;20 matches. Read the source code or contact the author for more information. The most difficulty part &quot;</span>
        <span class="s2">&quot;is to design an output API that works well with Polars, which is harder than one might think.&quot;</span>
    <span class="p">)</span>

    <span class="n">pat</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">patterns</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pl</span><span class="o">.</span><span class="n">Utf8</span><span class="p">)</span>
    <span class="n">cs</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">case_sensitive</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)</span>
    <span class="n">mk</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">match_kind</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Utf8</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_str</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
            <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
            <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_ac_match_str&quot;</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">pat</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">mk</span><span class="p">],</span>
            <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
            <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
            <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_ac_match&quot;</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">pat</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">mk</span><span class="p">],</span>
            <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">




<h3 id="polars_ds.str_ext.StrExt.ac_replace" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">ac_replace</span><span class="p">(</span><span class="n">patterns</span><span class="p">,</span> <span class="n">replacements</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Try to replace the patterns using the Aho-Corasick algorithm. The length of patterns should match
the length of replacements. If not, both sequences will be capped at the shorter length. If an error
happens during replacement, None will be returned.</p>
<p>Polars &gt;= 0.20 now has native aho-corasick support. The backend package is the same, though the function
api is different. See polars's str.contains_any and str.replace_many.</p>
<h5 id="polars_ds.str_ext.StrExt.ac_replace--parameters">Parameters</h5>
<p>patterns
    A list of strs, which are patterns to be matched
replacements
    A list of strs to replace the patterns with
parallel
    Whether to run the comparisons in parallel. Note that this is not always faster, especially
    when used with other expressions or in group_by/over context.</p>

          <details class="quote">
            <summary>Source code in <code>python/polars_ds/str_ext.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">652</span>
<span class="normal">653</span>
<span class="normal">654</span>
<span class="normal">655</span>
<span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span>
<span class="normal">663</span>
<span class="normal">664</span>
<span class="normal">665</span>
<span class="normal">666</span>
<span class="normal">667</span>
<span class="normal">668</span>
<span class="normal">669</span>
<span class="normal">670</span>
<span class="normal">671</span>
<span class="normal">672</span>
<span class="normal">673</span>
<span class="normal">674</span>
<span class="normal">675</span>
<span class="normal">676</span>
<span class="normal">677</span>
<span class="normal">678</span>
<span class="normal">679</span>
<span class="normal">680</span>
<span class="normal">681</span>
<span class="normal">682</span>
<span class="normal">683</span>
<span class="normal">684</span>
<span class="normal">685</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">ac_replace</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">patterns</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">replacements</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Try to replace the patterns using the Aho-Corasick algorithm. The length of patterns should match</span>
<span class="sd">    the length of replacements. If not, both sequences will be capped at the shorter length. If an error</span>
<span class="sd">    happens during replacement, None will be returned.</span>

<span class="sd">    Polars &gt;= 0.20 now has native aho-corasick support. The backend package is the same, though the function</span>
<span class="sd">    api is different. See polars&#39;s str.contains_any and str.replace_many.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    patterns</span>
<span class="sd">        A list of strs, which are patterns to be matched</span>
<span class="sd">    replacements</span>
<span class="sd">        A list of strs to replace the patterns with</span>
<span class="sd">    parallel</span>
<span class="sd">        Whether to run the comparisons in parallel. Note that this is not always faster, especially</span>
<span class="sd">        when used with other expressions or in group_by/over context.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">replacements</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">patterns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span>

    <span class="n">mlen</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">patterns</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">replacements</span><span class="p">))</span>
    <span class="n">pat</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">patterns</span><span class="p">[:</span><span class="n">mlen</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pl</span><span class="o">.</span><span class="n">Utf8</span><span class="p">)</span>
    <span class="n">rpl</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">replacements</span><span class="p">[:</span><span class="n">mlen</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pl</span><span class="o">.</span><span class="n">Utf8</span><span class="p">)</span>
    <span class="n">par</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">parallel</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
        <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
        <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_ac_replace&quot;</span><span class="p">,</span>
        <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">pat</span><span class="p">,</span> <span class="n">rpl</span><span class="p">,</span> <span class="n">par</span><span class="p">],</span>
        <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">




<h3 id="polars_ds.str_ext.StrExt.d_levenshtein" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">d_levenshtein</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_sim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Computes the Damerau-Levenshtein distance between this and the other str.</p>
<h5 id="polars_ds.str_ext.StrExt.d_levenshtein--parameters">Parameters</h5>
<p>other
    If this is a string, then the entire column will be compared with this string. If this
    is an expression, then an element-wise Levenshtein distance computation between this column
    and the other (given by the expression) will be performed.
parallel
    Whether to run the comparisons in parallel. Note that this is not always faster, especially
    when used with other expressions or in group_by/over context.
return_sim
    If true, return normalized Damerau-Levenshtein.</p>

          <details class="quote">
            <summary>Source code in <code>python/polars_ds/str_ext.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">d_levenshtein</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">],</span> <span class="n">parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">return_sim</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Damerau-Levenshtein distance between this and the other str.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    other</span>
<span class="sd">        If this is a string, then the entire column will be compared with this string. If this</span>
<span class="sd">        is an expression, then an element-wise Levenshtein distance computation between this column</span>
<span class="sd">        and the other (given by the expression) will be performed.</span>
<span class="sd">    parallel</span>
<span class="sd">        Whether to run the comparisons in parallel. Note that this is not always faster, especially</span>
<span class="sd">        when used with other expressions or in group_by/over context.</span>
<span class="sd">    return_sim</span>
<span class="sd">        If true, return normalized Damerau-Levenshtein.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">other_</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pl</span><span class="o">.</span><span class="n">Utf8</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">other_</span> <span class="o">=</span> <span class="n">other</span>

    <span class="k">if</span> <span class="n">return_sim</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
            <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
            <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_d_levenshtein_sim&quot;</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">other_</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">parallel</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)],</span>
            <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
            <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
            <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_d_levenshtein&quot;</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">other_</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">parallel</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)],</span>
            <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">




<h3 id="polars_ds.str_ext.StrExt.extract_numbers" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">extract_numbers</span><span class="p">(</span><span class="n">ignore_comma</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">join_by</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pl</span><span class="o">.</span><span class="n">Utf8</span><span class="p">)</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Extracts numbers from the string column, and stores them in a list.</p>
<h5 id="polars_ds.str_ext.StrExt.extract_numbers--parameters">Parameters</h5>
<p>ignore_comma
    Whether to remove all comma before matching for numbers
join_by
    If dtype is pl.Utf8, join the list of strings using the value given here
dtype
    The desired inner dtype for the extracted data. Should either be one of
    pl.NUMERIC_DTYPES or pl.Utf8</p>
<h5 id="polars_ds.str_ext.StrExt.extract_numbers--examples">Examples</h5>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
...     "survey":["0% of my time", "1% to 25% of my time", "75% to 99% of my time",
...            "50% to 74% of my time", "75% to 99% of my time",
...            "50% to 74% of my time"]
... })
df.select(pl.col("survey").str_ext.extract_numbers(dtype=pl.UInt32))
shape: (6, 1)
┌───────────┐
│ survey    │
│ ---       │
│ list[u32] │
╞═══════════╡
│ [0]       │
│ [1, 25]   │
│ [75, 99]  │
│ [50, 74]  │
│ [75, 99]  │
│ [50, 74]  │
└───────────┘
df.select(pl.col("survey").str_ext.extract_numbers(join_by="-", dtype=pl.Utf8))
shape: (6, 1)
┌────────┐
│ survey │
│ ---    │
│ str    │
╞════════╡
│ 0      │
│ 1-25   │
│ 75-99  │
│ 50-74  │
│ 75-99  │
│ 50-74  │
└────────┘</p>
</blockquote>
</blockquote>
</blockquote>

          <details class="quote">
            <summary>Source code in <code>python/polars_ds/str_ext.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">extract_numbers</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">ignore_comma</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">join_by</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">pl</span><span class="o">.</span><span class="n">DataType</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">Utf8</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts numbers from the string column, and stores them in a list.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ignore_comma</span>
<span class="sd">        Whether to remove all comma before matching for numbers</span>
<span class="sd">    join_by</span>
<span class="sd">        If dtype is pl.Utf8, join the list of strings using the value given here</span>
<span class="sd">    dtype</span>
<span class="sd">        The desired inner dtype for the extracted data. Should either be one of</span>
<span class="sd">        pl.NUMERIC_DTYPES or pl.Utf8</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; df = pl.DataFrame({</span>
<span class="sd">    ...     &quot;survey&quot;:[&quot;0% of my time&quot;, &quot;1% to 25% of my time&quot;, &quot;75% to 99% of my time&quot;,</span>
<span class="sd">    ...            &quot;50% to 74% of my time&quot;, &quot;75% to 99% of my time&quot;,</span>
<span class="sd">    ...            &quot;50% to 74% of my time&quot;]</span>
<span class="sd">    ... })</span>
<span class="sd">    &gt;&gt;&gt; df.select(pl.col(&quot;survey&quot;).str_ext.extract_numbers(dtype=pl.UInt32))</span>
<span class="sd">    shape: (6, 1)</span>
<span class="sd">    ┌───────────┐</span>
<span class="sd">    │ survey    │</span>
<span class="sd">    │ ---       │</span>
<span class="sd">    │ list[u32] │</span>
<span class="sd">    ╞═══════════╡</span>
<span class="sd">    │ [0]       │</span>
<span class="sd">    │ [1, 25]   │</span>
<span class="sd">    │ [75, 99]  │</span>
<span class="sd">    │ [50, 74]  │</span>
<span class="sd">    │ [75, 99]  │</span>
<span class="sd">    │ [50, 74]  │</span>
<span class="sd">    └───────────┘</span>
<span class="sd">    &gt;&gt;&gt; df.select(pl.col(&quot;survey&quot;).str_ext.extract_numbers(join_by=&quot;-&quot;, dtype=pl.Utf8))</span>
<span class="sd">    shape: (6, 1)</span>
<span class="sd">    ┌────────┐</span>
<span class="sd">    │ survey │</span>
<span class="sd">    │ ---    │</span>
<span class="sd">    │ str    │</span>
<span class="sd">    ╞════════╡</span>
<span class="sd">    │ 0      │</span>
<span class="sd">    │ 1-25   │</span>
<span class="sd">    │ 75-99  │</span>
<span class="sd">    │ 50-74  │</span>
<span class="sd">    │ 75-99  │</span>
<span class="sd">    │ 50-74  │</span>
<span class="sd">    └────────┘</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span>
    <span class="k">if</span> <span class="n">ignore_comma</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">replace_all</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="c1"># Find all numbers</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">extract_all</span><span class="p">(</span><span class="s2">&quot;(\d*\.?\d+)&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="n">pl</span><span class="o">.</span><span class="n">NUMERIC_DTYPES</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">list</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">pl</span><span class="o">.</span><span class="n">element</span><span class="p">()</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">pl</span><span class="o">.</span><span class="n">Utf8</span><span class="p">:</span>  <span class="c1"># As a list of strings</span>
        <span class="k">if</span> <span class="n">join_by</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">list</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">join_by</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">expr</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">




<h3 id="polars_ds.str_ext.StrExt.freq_removal" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">freq_removal</span><span class="p">(</span><span class="n">lower</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Removes from each documents words that are too frequent (in the entire dataset). This assumes
that the input expression represents lists of strings. E.g. output of tokenize.</p>
<h5 id="polars_ds.str_ext.StrExt.freq_removal--parameters">Parameters</h5>
<p>lower
    Lower percentile. If a word's frequency is &lt; than this, it will be removed.
upper
    Upper percentile. If a word's frequency is &gt; than this, it will be removed.
parallel
    Whether to run word count in parallel. It is not recommended when you are in a group_by
    context.</p>

          <details class="quote">
            <summary>Source code in <code>python/polars_ds/str_ext.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">freq_removal</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">lower</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span> <span class="n">upper</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.95</span><span class="p">,</span> <span class="n">parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes from each documents words that are too frequent (in the entire dataset). This assumes</span>
<span class="sd">    that the input expression represents lists of strings. E.g. output of tokenize.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lower</span>
<span class="sd">        Lower percentile. If a word&#39;s frequency is &lt; than this, it will be removed.</span>
<span class="sd">    upper</span>
<span class="sd">        Upper percentile. If a word&#39;s frequency is &gt; than this, it will be removed.</span>
<span class="sd">    parallel</span>
<span class="sd">        Whether to run word count in parallel. It is not recommended when you are in a group_by</span>
<span class="sd">        context.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">root_names</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">vc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">list</span><span class="o">.</span><span class="n">explode</span><span class="p">()</span><span class="o">.</span><span class="n">value_counts</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">)</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">lo</span> <span class="o">=</span> <span class="n">vc</span><span class="o">.</span><span class="n">struct</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">vc</span><span class="o">.</span><span class="n">struct</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span>
    <span class="n">remove</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">vc</span><span class="o">.</span><span class="n">filter</span><span class="p">((</span><span class="n">vc</span><span class="o">.</span><span class="n">struct</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">lo</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">vc</span><span class="o">.</span><span class="n">struct</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">u</span><span class="p">))</span>
        <span class="o">.</span><span class="n">struct</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="o">.</span><span class="n">implode</span><span class="p">()</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">list</span><span class="o">.</span><span class="n">set_difference</span><span class="p">(</span><span class="n">remove</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">




<h3 id="polars_ds.str_ext.StrExt.hamming" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">hamming</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Computes the hamming distance between two strings. If they do not have the same length, null will
be returned.</p>
<h5 id="polars_ds.str_ext.StrExt.hamming--parameters">Parameters</h5>
<p>other
    If this is a string, then the entire column will be compared with this string. If this
    is an expression, then an element-wise hamming distance computation between this column
    and the other (given by the expression) will be performed.
pad
    Whether to pad the string when lengths are not equal.
parallel
    Whether to run the comparisons in parallel. Note that this is not always faster, especially
    when used with other expressions or in group_by/over context.</p>

          <details class="quote">
            <summary>Source code in <code>python/polars_ds/str_ext.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">hamming</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">],</span> <span class="n">pad</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the hamming distance between two strings. If they do not have the same length, null will</span>
<span class="sd">    be returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    other</span>
<span class="sd">        If this is a string, then the entire column will be compared with this string. If this</span>
<span class="sd">        is an expression, then an element-wise hamming distance computation between this column</span>
<span class="sd">        and the other (given by the expression) will be performed.</span>
<span class="sd">    pad</span>
<span class="sd">        Whether to pad the string when lengths are not equal.</span>
<span class="sd">    parallel</span>
<span class="sd">        Whether to run the comparisons in parallel. Note that this is not always faster, especially</span>
<span class="sd">        when used with other expressions or in group_by/over context.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">other_</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">other_</span> <span class="o">=</span> <span class="n">other</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
        <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
        <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_hamming&quot;</span><span class="p">,</span>
        <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">other_</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">pad</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">),</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">parallel</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)],</span>
        <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">




<h3 id="polars_ds.str_ext.StrExt.infer_infreq" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">infer_infreq</span><span class="p">(</span><span class="o">*</span><span class="p">,</span> <span class="n">min_count</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_frac</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Infers infrequent categories (strings) by min_count or min_frac and return a list as output.</p>
<h5 id="polars_ds.str_ext.StrExt.infer_infreq--parameters">Parameters</h5>
<p>min_count
    If set, an infrequency category will be defined as a category with count &lt; this.
min_frac
    If set, an infrequency category will be defined as a category with pct &lt; this. min_count
    takes priority over this.
parallel
    Whether to run value_counts in parallel. This may not provide much speed up and is not
    recommended in a group_by context.</p>

          <details class="quote">
            <summary>Source code in <code>python/polars_ds/str_ext.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">infer_infreq</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">min_count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">min_frac</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Infers infrequent categories (strings) by min_count or min_frac and return a list as output.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    min_count</span>
<span class="sd">        If set, an infrequency category will be defined as a category with count &lt; this.</span>
<span class="sd">    min_frac</span>
<span class="sd">        If set, an infrequency category will be defined as a category with pct &lt; this. min_count</span>
<span class="sd">        takes priority over this.</span>
<span class="sd">    parallel</span>
<span class="sd">        Whether to run value_counts in parallel. This may not provide much speed up and is not</span>
<span class="sd">        recommended in a group_by context.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">root_names</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">vc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">value_counts</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">min_count</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">min_frac</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Either min_count or min_frac must be provided.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">min_count</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">infreq</span><span class="p">:</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span> <span class="o">=</span> <span class="n">vc</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">vc</span><span class="o">.</span><span class="n">struct</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_count</span><span class="p">)</span><span class="o">.</span><span class="n">struct</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">min_frac</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">infreq</span><span class="p">:</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span> <span class="o">=</span> <span class="n">vc</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
            <span class="n">vc</span><span class="o">.</span><span class="n">struct</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">)</span> <span class="o">/</span> <span class="n">vc</span><span class="o">.</span><span class="n">struct</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">min_frac</span>
        <span class="p">)</span><span class="o">.</span><span class="n">struct</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">infreq</span><span class="o">.</span><span class="n">implode</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">




<h3 id="polars_ds.str_ext.StrExt.is_stopword" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">is_stopword</span><span class="p">()</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Checks whether the string is a stopword or not.</p>

          <details class="quote">
            <summary>Source code in <code>python/polars_ds/str_ext.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">is_stopword</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks whether the string is a stopword or not.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
        <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
        <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_is_stopword&quot;</span><span class="p">,</span>
        <span class="n">args</span><span class="o">=</span><span class="p">[],</span>
        <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">




<h3 id="polars_ds.str_ext.StrExt.jaro" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">jaro</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Computes the Jaro similarity between this and the other str. Jaro distance = 1 - Jaro sim.</p>
<h5 id="polars_ds.str_ext.StrExt.jaro--parameters">Parameters</h5>
<p>other
    If this is a string, then the entire column will be compared with this string. If this
    is an expression, then an element-wise Levenshtein distance computation between this column
    and the other (given by the expression) will be performed.
parallel
    Whether to run the comparisons in parallel. Note that this is not always faster, especially
    when used with other expressions or in group_by/over context.</p>

          <details class="quote">
            <summary>Source code in <code>python/polars_ds/str_ext.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">jaro</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">],</span> <span class="n">parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Jaro similarity between this and the other str. Jaro distance = 1 - Jaro sim.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    other</span>
<span class="sd">        If this is a string, then the entire column will be compared with this string. If this</span>
<span class="sd">        is an expression, then an element-wise Levenshtein distance computation between this column</span>
<span class="sd">        and the other (given by the expression) will be performed.</span>
<span class="sd">    parallel</span>
<span class="sd">        Whether to run the comparisons in parallel. Note that this is not always faster, especially</span>
<span class="sd">        when used with other expressions or in group_by/over context.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">other_</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pl</span><span class="o">.</span><span class="n">Utf8</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">other_</span> <span class="o">=</span> <span class="n">other</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
        <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
        <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_jaro&quot;</span><span class="p">,</span>
        <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">other_</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">parallel</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)],</span>
        <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">




<h3 id="polars_ds.str_ext.StrExt.jw" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">jw</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Computes the Jaro-Winker similarity between this and the other str.
Jaro-Winkler distance = 1 - Jaro-Winkler sim.</p>
<h5 id="polars_ds.str_ext.StrExt.jw--parameters">Parameters</h5>
<p>other
    If this is a string, then the entire column will be compared with this string. If this
    is an expression, then an element-wise Levenshtein distance computation between this column
    and the other (given by the expression) will be performed.
weight
    Weight for prefix. A typical value is 0.1.
parallel
    Whether to run the comparisons in parallel. Note that this is not always faster, especially
    when used with other expressions or in group_by/over context.</p>

          <details class="quote">
            <summary>Source code in <code>python/polars_ds/str_ext.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">jw</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">],</span> <span class="n">weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Jaro-Winker similarity between this and the other str.</span>
<span class="sd">    Jaro-Winkler distance = 1 - Jaro-Winkler sim.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    other</span>
<span class="sd">        If this is a string, then the entire column will be compared with this string. If this</span>
<span class="sd">        is an expression, then an element-wise Levenshtein distance computation between this column</span>
<span class="sd">        and the other (given by the expression) will be performed.</span>
<span class="sd">    weight</span>
<span class="sd">        Weight for prefix. A typical value is 0.1.</span>
<span class="sd">    parallel</span>
<span class="sd">        Whether to run the comparisons in parallel. Note that this is not always faster, especially</span>
<span class="sd">        when used with other expressions or in group_by/over context.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">other_</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Utf8</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">other_</span> <span class="o">=</span> <span class="n">other</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
        <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
        <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_jw&quot;</span><span class="p">,</span>
        <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">other_</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Float64</span><span class="p">),</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">parallel</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)],</span>
        <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">




<h3 id="polars_ds.str_ext.StrExt.levenshtein" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">levenshtein</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_sim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Computes the Levenshtein distance between this and the other str.</p>
<h5 id="polars_ds.str_ext.StrExt.levenshtein--parameters">Parameters</h5>
<p>other
    If this is a string, then the entire column will be compared with this string. If this
    is an expression, then an element-wise Levenshtein distance computation between this column
    and the other (given by the expression) will be performed.
parallel
    Whether to run the comparisons in parallel. Note that this is not always faster, especially
    when used with other expressions or in group_by/over context.
return_sim
    If true, return normalized Levenshtein.</p>

          <details class="quote">
            <summary>Source code in <code>python/polars_ds/str_ext.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">levenshtein</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">],</span> <span class="n">parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">return_sim</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Levenshtein distance between this and the other str.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    other</span>
<span class="sd">        If this is a string, then the entire column will be compared with this string. If this</span>
<span class="sd">        is an expression, then an element-wise Levenshtein distance computation between this column</span>
<span class="sd">        and the other (given by the expression) will be performed.</span>
<span class="sd">    parallel</span>
<span class="sd">        Whether to run the comparisons in parallel. Note that this is not always faster, especially</span>
<span class="sd">        when used with other expressions or in group_by/over context.</span>
<span class="sd">    return_sim</span>
<span class="sd">        If true, return normalized Levenshtein.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">other_</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pl</span><span class="o">.</span><span class="n">Utf8</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">other_</span> <span class="o">=</span> <span class="n">other</span>

    <span class="k">if</span> <span class="n">return_sim</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
            <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
            <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_levenshtein_sim&quot;</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">other_</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">parallel</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)],</span>
            <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
            <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
            <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_levenshtein&quot;</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">other_</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">parallel</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)],</span>
            <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">




<h3 id="polars_ds.str_ext.StrExt.levenshtein_within" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">levenshtein_within</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">bound</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Returns whether the Levenshtein distance between self and other is &lt;= bound. This is much
faster than computing levenshtein distance and then doing &lt;= bound.</p>
<h5 id="polars_ds.str_ext.StrExt.levenshtein_within--parameters">Parameters</h5>
<p>other
    If this is a string, then the entire column will be compared with this string. If this
    is an expression, then an element-wise Levenshtein distance computation between this column
    and the other (given by the expression) will be performed.
bound
    Closed upper bound. If levenshtein distance &lt;= bound, return true and false otherwise.
parallel
    Whether to run the comparisons in parallel. Note that this is not always faster, especially
    when used with other expressions or in group_by/over context.</p>

          <details class="quote">
            <summary>Source code in <code>python/polars_ds/str_ext.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">levenshtein_within</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">],</span>
    <span class="n">bound</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns whether the Levenshtein distance between self and other is &lt;= bound. This is much</span>
<span class="sd">    faster than computing levenshtein distance and then doing &lt;= bound.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    other</span>
<span class="sd">        If this is a string, then the entire column will be compared with this string. If this</span>
<span class="sd">        is an expression, then an element-wise Levenshtein distance computation between this column</span>
<span class="sd">        and the other (given by the expression) will be performed.</span>
<span class="sd">    bound</span>
<span class="sd">        Closed upper bound. If levenshtein distance &lt;= bound, return true and false otherwise.</span>
<span class="sd">    parallel</span>
<span class="sd">        Whether to run the comparisons in parallel. Note that this is not always faster, especially</span>
<span class="sd">        when used with other expressions or in group_by/over context.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">other_</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Utf8</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">other_</span> <span class="o">=</span> <span class="n">other</span>

    <span class="n">bound</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">bound</span><span class="p">),</span> <span class="n">pl</span><span class="o">.</span><span class="n">UInt32</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
        <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
        <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_levenshtein_within&quot;</span><span class="p">,</span>
        <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">other_</span><span class="p">,</span> <span class="n">bound</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">parallel</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)],</span>
        <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">




<h3 id="polars_ds.str_ext.StrExt.line_count" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">line_count</span><span class="p">()</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Return the line count of the string column.</p>

          <details class="quote">
            <summary>Source code in <code>python/polars_ds/str_ext.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">line_count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the line count of the string column.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">count_matches</span><span class="p">(</span><span class="n">pattern</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">




<h3 id="polars_ds.str_ext.StrExt.merge_infreq" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">merge_infreq</span><span class="p">(</span><span class="o">*</span><span class="p">,</span> <span class="n">min_count</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_frac</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s1">&#39;|&#39;</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Merge infrequent categories (strings) in the column into one category (string) separated by a
separator. This is useful when you want to do one-hot-encoding but do not want too many distinct
values because of low count values. However, this does not mean that the categories are similar
with respect to the your modelling problem.</p>
<h5 id="polars_ds.str_ext.StrExt.merge_infreq--parameters">Parameters</h5>
<p>min_count
    If set, an infrequency category will be defined as a category with count &lt; this.
min_frac
    If set, an infrequency category will be defined as a category with pct &lt; this. min_count
    takes priority over this.
separator
    What separator to use when joining the categories. E.g if "a" and "b" are rare categories,
    and separator = "|", they will be mapped to "a|b"
parallel
    Whether to run value_counts in parallel. This may not provide much speed up and is not
    recommended in a group_by context.</p>

          <details class="quote">
            <summary>Source code in <code>python/polars_ds/str_ext.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">merge_infreq</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">min_count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">min_frac</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">separator</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;|&quot;</span><span class="p">,</span>
    <span class="n">parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merge infrequent categories (strings) in the column into one category (string) separated by a</span>
<span class="sd">    separator. This is useful when you want to do one-hot-encoding but do not want too many distinct</span>
<span class="sd">    values because of low count values. However, this does not mean that the categories are similar</span>
<span class="sd">    with respect to the your modelling problem.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    min_count</span>
<span class="sd">        If set, an infrequency category will be defined as a category with count &lt; this.</span>
<span class="sd">    min_frac</span>
<span class="sd">        If set, an infrequency category will be defined as a category with pct &lt; this. min_count</span>
<span class="sd">        takes priority over this.</span>
<span class="sd">    separator</span>
<span class="sd">        What separator to use when joining the categories. E.g if &quot;a&quot; and &quot;b&quot; are rare categories,</span>
<span class="sd">        and separator = &quot;|&quot;, they will be mapped to &quot;a|b&quot;</span>
<span class="sd">    parallel</span>
<span class="sd">        Whether to run value_counts in parallel. This may not provide much speed up and is not</span>
<span class="sd">        recommended in a group_by context.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Will be fixed soon and sort will not be needed</span>
    <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">root_names</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">vc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">value_counts</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">min_count</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">min_frac</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Either min_count or min_frac must be provided.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">min_count</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">to_merge</span><span class="p">:</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span> <span class="o">=</span> <span class="n">vc</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">vc</span><span class="o">.</span><span class="n">struct</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_count</span><span class="p">)</span><span class="o">.</span><span class="n">struct</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">min_frac</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">to_merge</span><span class="p">:</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span> <span class="o">=</span> <span class="n">vc</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
            <span class="n">vc</span><span class="o">.</span><span class="n">struct</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">)</span> <span class="o">/</span> <span class="n">vc</span><span class="o">.</span><span class="n">struct</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">min_frac</span>
        <span class="p">)</span><span class="o">.</span><span class="n">struct</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">pl</span><span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">is_in</span><span class="p">(</span><span class="n">to_merge</span><span class="p">))</span>
        <span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">to_merge</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">pl</span><span class="o">.</span><span class="n">Utf8</span><span class="p">)</span><span class="o">.</span><span class="n">fill_null</span><span class="p">(</span><span class="s2">&quot;null&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">implode</span><span class="p">()</span><span class="o">.</span><span class="n">first</span><span class="p">()</span><span class="o">.</span><span class="n">list</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">separator</span><span class="p">))</span>
        <span class="o">.</span><span class="n">otherwise</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="p">)</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">




<h3 id="polars_ds.str_ext.StrExt.osa" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">osa</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_sim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Computes the Optimal String Alignment distance between this and the other str.</p>
<h5 id="polars_ds.str_ext.StrExt.osa--parameters">Parameters</h5>
<p>other
    If this is a string, then the entire column will be compared with this string. If this
    is an expression, then an element-wise OSA distance computation between this column
    and the other (given by the expression) will be performed.
parallel
    Whether to run the comparisons in parallel. Note that this is not always faster, especially
    when used with other expressions or in group_by/over context.
return_sim
    If true, return normalized OSA similarity.</p>

          <details class="quote">
            <summary>Source code in <code>python/polars_ds/str_ext.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">osa</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">],</span> <span class="n">parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">return_sim</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Optimal String Alignment distance between this and the other str.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    other</span>
<span class="sd">        If this is a string, then the entire column will be compared with this string. If this</span>
<span class="sd">        is an expression, then an element-wise OSA distance computation between this column</span>
<span class="sd">        and the other (given by the expression) will be performed.</span>
<span class="sd">    parallel</span>
<span class="sd">        Whether to run the comparisons in parallel. Note that this is not always faster, especially</span>
<span class="sd">        when used with other expressions or in group_by/over context.</span>
<span class="sd">    return_sim</span>
<span class="sd">        If true, return normalized OSA similarity.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">other_</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pl</span><span class="o">.</span><span class="n">Utf8</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">other_</span> <span class="o">=</span> <span class="n">other</span>

    <span class="k">if</span> <span class="n">return_sim</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
            <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
            <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_osa_sim&quot;</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">other_</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">parallel</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)],</span>
            <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
            <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
            <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_osa&quot;</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">other_</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">parallel</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)],</span>
            <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">




<h3 id="polars_ds.str_ext.StrExt.overlap_coeff" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">overlap_coeff</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">substr_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Treats substrings of size <code>substr_size</code> as a set. And computes the overlap coefficient as
similarity between this word and the other. This is not the same as comparing bigrams.</p>
<h5 id="polars_ds.str_ext.StrExt.overlap_coeff--parameters">Parameters</h5>
<p>other
    If this is a string, then the entire column will be compared with this string. If this
    is an expression, then perform element-wise jaccard similarity computation between this column
    and the other (given by the expression).
substr_size
    The substring size for Jaccard similarity. E.g. if substr_size = 2, "apple" will be decomposed into
    the set ('ap', 'pp', 'pl', 'le') before being compared.
parallel
    Whether to run the comparisons in parallel. Note that this is not always faster, especially
    when used with other expressions or in group_by/over context.</p>

          <details class="quote">
            <summary>Source code in <code>python/polars_ds/str_ext.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">overlap_coeff</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">],</span> <span class="n">substr_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Treats substrings of size `substr_size` as a set. And computes the overlap coefficient as</span>
<span class="sd">    similarity between this word and the other. This is not the same as comparing bigrams.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    other</span>
<span class="sd">        If this is a string, then the entire column will be compared with this string. If this</span>
<span class="sd">        is an expression, then perform element-wise jaccard similarity computation between this column</span>
<span class="sd">        and the other (given by the expression).</span>
<span class="sd">    substr_size</span>
<span class="sd">        The substring size for Jaccard similarity. E.g. if substr_size = 2, &quot;apple&quot; will be decomposed into</span>
<span class="sd">        the set (&#39;ap&#39;, &#39;pp&#39;, &#39;pl&#39;, &#39;le&#39;) before being compared.</span>
<span class="sd">    parallel</span>
<span class="sd">        Whether to run the comparisons in parallel. Note that this is not always faster, especially</span>
<span class="sd">        when used with other expressions or in group_by/over context.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">other_</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Utf8</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">other_</span> <span class="o">=</span> <span class="n">other</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
        <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
        <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_overlap_coeff&quot;</span><span class="p">,</span>
        <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">other_</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">substr_size</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">UInt32</span><span class="p">),</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">parallel</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)],</span>
        <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">




<h3 id="polars_ds.str_ext.StrExt.snowball" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">snowball</span><span class="p">(</span><span class="n">no_stopwords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Applies the snowball stemmer for the column. The column is supposed to be a column of single words.</p>
<h5 id="polars_ds.str_ext.StrExt.snowball--parameters">Parameters</h5>
<p>no_stopwords
    If true, stopwords will be mapped to None. If false, stopwords will be stemmed.
parallel
    Whether to run the comparisons in parallel. Note that this is not always faster, especially
    when used with other expressions or in group_by/over context.</p>

          <details class="quote">
            <summary>Source code in <code>python/polars_ds/str_ext.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">snowball</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">no_stopwords</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies the snowball stemmer for the column. The column is supposed to be a column of single words.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    no_stopwords</span>
<span class="sd">        If true, stopwords will be mapped to None. If false, stopwords will be stemmed.</span>
<span class="sd">    parallel</span>
<span class="sd">        Whether to run the comparisons in parallel. Note that this is not always faster, especially</span>
<span class="sd">        when used with other expressions or in group_by/over context.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
        <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
        <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_snowball_stem&quot;</span><span class="p">,</span>
        <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">no_stopwords</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">),</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">parallel</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)],</span>
        <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">




<h3 id="polars_ds.str_ext.StrExt.sorensen_dice" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">sorensen_dice</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">substr_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Treats substrings of size <code>substr_size</code> as a set. And computes the Sorensen-Dice similarity between
this word and the other. This is not the same as comparing bigrams.</p>
<h5 id="polars_ds.str_ext.StrExt.sorensen_dice--parameters">Parameters</h5>
<p>other
    If this is a string, then the entire column will be compared with this string. If this
    is an expression, then perform element-wise jaccard similarity computation between this column
    and the other (given by the expression).
substr_size
    The substring size for Jaccard similarity. E.g. if substr_size = 2, "apple" will be decomposed into
    the set ('ap', 'pp', 'pl', 'le') before being compared.
parallel
    Whether to run the comparisons in parallel. Note that this is not always faster, especially
    when used with other expressions or in group_by/over context.</p>

          <details class="quote">
            <summary>Source code in <code>python/polars_ds/str_ext.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">sorensen_dice</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">],</span> <span class="n">substr_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Treats substrings of size `substr_size` as a set. And computes the Sorensen-Dice similarity between</span>
<span class="sd">    this word and the other. This is not the same as comparing bigrams.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    other</span>
<span class="sd">        If this is a string, then the entire column will be compared with this string. If this</span>
<span class="sd">        is an expression, then perform element-wise jaccard similarity computation between this column</span>
<span class="sd">        and the other (given by the expression).</span>
<span class="sd">    substr_size</span>
<span class="sd">        The substring size for Jaccard similarity. E.g. if substr_size = 2, &quot;apple&quot; will be decomposed into</span>
<span class="sd">        the set (&#39;ap&#39;, &#39;pp&#39;, &#39;pl&#39;, &#39;le&#39;) before being compared.</span>
<span class="sd">    parallel</span>
<span class="sd">        Whether to run the comparisons in parallel. Note that this is not always faster, especially</span>
<span class="sd">        when used with other expressions or in group_by/over context.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">other_</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pl</span><span class="o">.</span><span class="n">Utf8</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">other_</span> <span class="o">=</span> <span class="n">other</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
        <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
        <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_sorensen_dice&quot;</span><span class="p">,</span>
        <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">other_</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">substr_size</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">UInt32</span><span class="p">),</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">parallel</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)],</span>
        <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">




<h3 id="polars_ds.str_ext.StrExt.str_jaccard" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">str_jaccard</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">substr_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Treats substrings of size <code>substr_size</code> as a set. And computes the jaccard similarity between
this word and the other. This is not the same as comparing bigrams.</p>
<h5 id="polars_ds.str_ext.StrExt.str_jaccard--parameters">Parameters</h5>
<p>other
    If this is a string, then the entire column will be compared with this string. If this
    is an expression, then perform element-wise jaccard similarity computation between this column
    and the other (given by the expression).
substr_size
    The substring size for Jaccard similarity. E.g. if substr_size = 2, "apple" will be decomposed into
    the set ('ap', 'pp', 'pl', 'le') before being compared.
parallel
    Whether to run the comparisons in parallel. Note that this is not always faster, especially
    when used with other expressions or in group_by/over context.</p>

          <details class="quote">
            <summary>Source code in <code>python/polars_ds/str_ext.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">str_jaccard</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">],</span> <span class="n">substr_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Treats substrings of size `substr_size` as a set. And computes the jaccard similarity between</span>
<span class="sd">    this word and the other. This is not the same as comparing bigrams.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    other</span>
<span class="sd">        If this is a string, then the entire column will be compared with this string. If this</span>
<span class="sd">        is an expression, then perform element-wise jaccard similarity computation between this column</span>
<span class="sd">        and the other (given by the expression).</span>
<span class="sd">    substr_size</span>
<span class="sd">        The substring size for Jaccard similarity. E.g. if substr_size = 2, &quot;apple&quot; will be decomposed into</span>
<span class="sd">        the set (&#39;ap&#39;, &#39;pp&#39;, &#39;pl&#39;, &#39;le&#39;) before being compared.</span>
<span class="sd">    parallel</span>
<span class="sd">        Whether to run the comparisons in parallel. Note that this is not always faster, especially</span>
<span class="sd">        when used with other expressions or in group_by/over context.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">other_</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pl</span><span class="o">.</span><span class="n">Utf8</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">other_</span> <span class="o">=</span> <span class="n">other</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
        <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
        <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_str_jaccard&quot;</span><span class="p">,</span>
        <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">other_</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">substr_size</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">UInt32</span><span class="p">),</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">parallel</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)],</span>
        <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">




<h3 id="polars_ds.str_ext.StrExt.tokenize" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">tokenize</span><span class="p">(</span><span class="n">pattern</span><span class="o">=</span><span class="s1">&#39;(?u)</span><span class="se">\\</span><span class="s1">b</span><span class="se">\\</span><span class="s1">w</span><span class="se">\\</span><span class="s1">w+</span><span class="se">\\</span><span class="s1">b&#39;</span><span class="p">,</span> <span class="n">stem</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Tokenize the string according to the pattern. This will only extract the words
satisfying the pattern.</p>
<h5 id="polars_ds.str_ext.StrExt.tokenize--parameters">Parameters</h5>
<p>pattern
    The word pattern to extract
stem
    If true, then this will stem the words and keep only the unique ones. Stop words
    will be removed. (Common words like <code>he</code>, <code>she</code>, etc., will be removed.)</p>

          <details class="quote">
            <summary>Source code in <code>python/polars_ds/str_ext.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">tokenize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;(?u)\b\w\w+\b&quot;</span><span class="p">,</span> <span class="n">stem</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tokenize the string according to the pattern. This will only extract the words</span>
<span class="sd">    satisfying the pattern.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pattern</span>
<span class="sd">        The word pattern to extract</span>
<span class="sd">    stem</span>
<span class="sd">        If true, then this will stem the words and keep only the unique ones. Stop words</span>
<span class="sd">        will be removed. (Common words like `he`, `she`, etc., will be removed.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">extract_all</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">stem</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">list</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span>
            <span class="n">pl</span><span class="o">.</span><span class="n">element</span><span class="p">()</span>
            <span class="o">.</span><span class="n">register_plugin</span><span class="p">(</span>
                <span class="n">lib</span><span class="o">=</span><span class="n">_lib</span><span class="p">,</span>
                <span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;pl_snowball_stem&quot;</span><span class="p">,</span>
                <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">),</span> <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)],</span>
                <span class="n">is_elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>  <span class="c1"># True to no stop word, False to Parallel</span>
            <span class="o">.</span><span class="n">drop_nulls</span><span class="p">()</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>



  </div>

  </div>

</div>




  </div>

  </div>

</div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.f886a092.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d7c377c4.min.js"></script>
      
    
  </body>
</html>